<!DOCTYPE html>
<html>  <head>
    <meta charset="utf-8" />
    <title>High-Performance Networking Programming in C</title>

    <!--Meta For No Index-->
    <meta name="robots" content="noindex, Nofollow, Noimageindex">

    <!--mobile responsive meta-->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta name="generator" content="Hugo 0.95.0" />
    <!-- Critical CSS -->
    
    <link href="https://girish1729.github.io/scss/critical.min.css" rel="stylesheet" />
  

    <!-- Favicon -->
    <link rel="shortcut icon" href="https://girish1729.github.io/images/favicon.ico" type="image/x-icon" />
    <link rel="icon" href="https://girish1729.github.io/images/favicon.png" type="image/x-icon" />

    

    
  </head>

<body>
<header class="header">
  <nav class="main-nav navbar navbar-expand-lg main-nav-colored">
    <div class="container-fluid">
      <a href="https://girish1729.github.io" class="navbar-brand">
        <img src="https://girish1729.github.io/images/logo.png" alt="site-logo" />
      </a>
      <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#mainNav" aria-expanded="false">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div
        class="collapse navbar-collapse nav-list"
        id="mainNav"
      >
        <ul class="navbar-nav ml-auto">
          
          
          
          <li class="nav-item ">
             <a class="nav-link scroll-to" href="https://girish1729.github.io/start-here">Start Here</a>
          </li>
          
          <li class="nav-item ">
             <a class="nav-link scroll-to" href="https://girish1729.github.io/blog/">Blog</a>
          </li>
          
          <li class="nav-item ">
             <a class="nav-link scroll-to" href="https://girish1729.github.io#faq">FAQ</a>
          </li>
          
          <li class="nav-item ">
             <a class="nav-link scroll-to" href="https://girish1729.github.io/contact/">Contact</a>
          </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>
<div id="content">
<article class="post">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <div class="post-title">
          <h2>High-Performance Networking Programming in C</h2>
        </div>
        <div class="post-meta">
          <p><span>November 28, 2018</span> in 
            
          </p>
        </div>
        <div class="post-image">
          <img src="https://girish1729.github.io/images/blog/c.webp" alt="feature-image">
        </div>
        <div class="post-body">
          <h1 id="high-performance-networking-programming-in-c">High-Performance Networking Programming in C</h1>
<p>HOWTOs</p>
<p>by Girish Venkatachalam on November 1, 2007
TCP/IP network programming in C on Linux is good fun. All the advanced
features of the stack are at your disposal, and you can do lot of
interesting things in user space without getting into kernel
programming.</p>
<p>Performance enhancement is as much an art as it is a science. It is an
iterative process, akin to an artist gingerly stroking a painting with a
fine brush, looking at the work from multiple angles at different
distances until satisfied with the result.</p>
<p>The analogy to this artistic touch is the rich set of tools that Linux
provides in order to measure network throughput and performance. Based
on this, programmers tweak certain parameters or sometimes even
re-engineer their solutions to achieve the expected results.</p>
<p>I won&rsquo;t dwell further upon the artistic side of high-performance
programming. In this article, I focus on certain generic mechanisms that
are guaranteed to provide a noticeable improvement. Based on this, you
should be able to make the final touch with the help of the right tools.</p>
<p>I deal mostly with TCP, because the kernel does the bandwidth management
and flow control for us. Of course, we no longer have to worry about
reliability either. If you are interested in performance and high-volume
traffic, you will arrive at TCP anyway.</p>
<p>What Is Bandwidth?
Once we answer that question, we can ask ourselves another useful
question, “How can we get the best out of the available bandwidth?”</p>
<p>Bandwidth, as defined by Wikipedia, is the difference between the higher
and lower cutoff frequencies of a communication channel. Cutoff
frequencies are determined by basic laws of physics—nothing much we can
do there.</p>
<p>But, there is a lot we can do elsewhere. According to Claude Shannon,
the practically achievable bandwidth is determined by the level of noise
in the channel, the data encoding used and so on. Taking a cue from
Shannon&rsquo;s idea, we should “encode” our data in such a way that the
protocol overhead is minimal and most of the bits are used to carry
useful payload data.</p>
<p>TCP/IP packets work in a packet-switched environment. We have to contend
with other nodes on the network. There is no concept of dedicated
bandwidth in the LAN environment where your product is most likely to
reside. This is something we can control with a bit of programming.</p>
<p>Non-Blocking TCP
Here&rsquo;s one way to maximize throughput if the bottleneck is your local
LAN (this might also be the case in certain crowded ADSL deployments).
Simply use multiple TCP connections. That way, you can ensure that you
get all the attention at the expense of the other nodes in the LAN. This
is the secret of download accelerators. They open multiple TCP
connections to FTP and HTTP servers and download a file in pieces and
reassemble it at multiple offsets. This is not “playing” nicely though.</p>
<p>We want to be well-behaved citizens, which is where non-blocking I/O
comes in. The traditional approach of blocking reads and writes on the
network is very easy to program, but if you are interested in filling
the pipe available to you by pumping packets, you must use non-blocking
TCP sockets. Listing 1 shows a simple code fragment using non-blocking
sockets for network read and write.</p>
<p>Listing 1. nonblock.c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* set socket non blocking */</span>
</span></span><span style="display:flex;"><span>fl <span style="color:#f92672">=</span> fcntl(accsock, F_GETFL);
</span></span><span style="display:flex;"><span>fcntl(accsock, F_SETFL, fl <span style="color:#f92672">|</span> O_NONBLOCK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poll_wait</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> events)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> pollfd pollfds[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    memset((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>pollfds, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(pollfds));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pollfds[<span style="color:#ae81ff">0</span>].fd <span style="color:#f92672">=</span> fd;
</span></span><span style="display:flex;"><span>    pollfds[<span style="color:#ae81ff">0</span>].events <span style="color:#f92672">=</span> events;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> poll(pollfds, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;poll()&#34;</span>);
</span></span><span style="display:flex;"><span>        errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Poll failed&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">readmore</span>(<span style="color:#66d9ef">int</span> sock, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, size_t n) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fd_set rfds;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ret, bytes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        poll_wait(sock,POLLERR <span style="color:#f92672">|</span> POLLIN );
</span></span><span style="display:flex;"><span>        bytes <span style="color:#f92672">=</span> readall(sock, buf, n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> bytes) {
</span></span><span style="display:flex;"><span>                perror(<span style="color:#e6db74">&#34;Connection closed&#34;</span>);
</span></span><span style="display:flex;"><span>                errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Readmore Connection closure&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* NOT REACHED */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> bytes;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">readall</span>(<span style="color:#66d9ef">int</span> sock, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, size_t n) {
</span></span><span style="display:flex;"><span>        size_t pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ssize_t res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> pos) {
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> read (sock, buf <span style="color:#f92672">+</span> pos, n <span style="color:#f92672">-</span> pos);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span> ((<span style="color:#66d9ef">int</span>)res) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR <span style="color:#f92672">||</span> errno <span style="color:#f92672">==</span> EAGAIN)
</span></span><span style="display:flex;"><span>                                        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                errno <span style="color:#f92672">=</span> EPIPE;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> pos;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                pos <span style="color:#f92672">+=</span> (size_t)res;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (pos);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writenw</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, size_t n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        size_t pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ssize_t res;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> pos) {
</span></span><span style="display:flex;"><span>                poll_wait(fd, POLLOUT <span style="color:#f92672">|</span> POLLERR);
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> write (fd, buf <span style="color:#f92672">+</span> pos, n <span style="color:#f92672">-</span> pos);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span> ((<span style="color:#66d9ef">int</span>)res) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR <span style="color:#f92672">||</span> errno <span style="color:#f92672">==</span> EAGAIN)
</span></span><span style="display:flex;"><span>                                        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                errno <span style="color:#f92672">=</span> EPIPE;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> pos;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                pos <span style="color:#f92672">+=</span> (size_t)res;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (pos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that you should use fcntl(2) instead of setsockopt(2) for setting
the socket file descriptor to non-blocking mode. Use poll(2) or
select(2) to figure out when the socket is ready to read or write.
select(2) cannot figure out when the socket is ready to write, so watch
out for this.</p>
<p>How does non-blocking I/O provide better throughput? The OS schedules
the user process differently in the case of blocking and non-blocking
I/O. When you block, the process “sleeps”, which leads to a context
switch. When you use non-blocking sockets, this problem is avoided.</p>
<p>Scatter/Gather I/O
The other interesting technique is scatter/gather I/O or using readv(2)
and writev(2) for network and/or disk I/O.</p>
<p>Instead of using buffers as the unit of data transfer, an array of
buffers is used instead. Each buffer can be a different length, and this
is what makes it so interesting.</p>
<p>You can transfer large chunks of data split between multiple
sources/destinations from/to the network. This could be a useful
technique, depending upon your application. Listing 2 shows a code
snippet to illustrate its use.</p>
<p>Listing 2. uio.c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/uio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>size_t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writeuio</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> iovec <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">int</span> cnt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        size_t pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ssize_t res;
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> iov[<span style="color:#ae81ff">0</span>].iov_cnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> pos) {
</span></span><span style="display:flex;"><span>                poll_wait(fd, POLLOUT <span style="color:#f92672">|</span> POLLERR);
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> writev (fd, iov[<span style="color:#ae81ff">0</span>].iov_base <span style="color:#f92672">+</span> pos, n <span style="color:#f92672">-</span> pos);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span> ((<span style="color:#66d9ef">int</span>)res) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR <span style="color:#f92672">||</span> errno <span style="color:#f92672">==</span> EAGAIN)
</span></span><span style="display:flex;"><span>                                        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                errno <span style="color:#f92672">=</span> EPIPE;
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> pos;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                pos <span style="color:#f92672">+=</span> (size_t)res;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (pos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When you combine scatter/gather I/O with non-blocking sockets, things
get a little complex, as shown in Figure 1. The code for tackling this
hairy issue is shown in Listing 3.</p>
<p>High-Performance Networking Programming in C
Figure 1. Possibilities in Non-Blocking Write with Scatter/Gather I/O</p>
<p>Listing 3. nonblockuio.c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>writeiovall(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> iov <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">int</span> nvec) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i, bytes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> nvec) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                        rv <span style="color:#f92672">=</span> writev(fd, <span style="color:#f92672">&amp;</span>vec[i], nvec <span style="color:#f92672">-</span> i);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">while</span> (rv <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                                (errno <span style="color:#f92672">==</span> EINTR <span style="color:#f92672">||</span> errno <span style="color:#f92672">==</span> EAGAIN));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (rv <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">!=</span> EINTR <span style="color:#f92672">&amp;&amp;</span> errno <span style="color:#f92672">!=</span> EAGAIN) {
</span></span><span style="display:flex;"><span>                                perror(<span style="color:#e6db74">&#34;write&#34;</span>);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                bytes <span style="color:#f92672">+=</span> rv;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* recalculate vec to deal with partial writes */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (rv <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (rv <span style="color:#f92672">&lt;</span> vec[i].iov_len) {
</span></span><span style="display:flex;"><span>                                vec[i].iov_base <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>vec[i].iov_base <span style="color:#f92672">+</span> rv;
</span></span><span style="display:flex;"><span>                                vec[i].iov_len <span style="color:#f92672">-=</span> rv;
</span></span><span style="display:flex;"><span>                                rv <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                                rv <span style="color:#f92672">-=</span> vec[i].iov_len;
</span></span><span style="display:flex;"><span>                                <span style="color:#f92672">++</span>i;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* We should get here only after we write out everything */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A partial write of any buffer can occur, or you can get any combination
of a few full writes and few partial writes. Therefore, the while loop
has to take care of all such possible combinations.</p>
<p>mmap(2) Disk I/O
Network programming is not all about sockets, however. We still haven&rsquo;t
solved the problem of having to use hard disks, which are mechanical
devices and consequently are much slower than main memory and even the
network in many, if not most, cases (especially high-performance
computing environments).</p>
<p>You can use some other form of persistent storage, but today, none
matches the huge storage capacity that hard disks offer. Currently, most
applications on the Internet push several gigabytes of data, and you end
up with heavy storage needs anyway.</p>
<p>To test disk performance, type this:</p>
<p>$ hdparm -rT /dev/sda (/dev/hda if IDE)
Check whether you are getting good throughput. If not, enable DMA and
other safe options using this command:</p>
<p>$ hdparm -d 1 -A 1 -m 16 -u 1 -a 64 /dev/sda
We also need to be able to avoid redundant copies and other
time-consuming CPU operations to squeeze the maximum bandwidth from the
network. A very effective tool for achieving that is the versatile
mmap(2) system call. This is a very useful technique for avoiding the
copy-to-buffer cache and, hence, improves performance for network I/O.
But, if you use mmap(2) with NFS, you are asking for trouble. Listing 4
shows a code snippet that illustrates the use of mmap(2) for both
reading and writing files.</p>
<p>Listing 4. mmap.c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/******************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * mmap(2) file write                     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *                                        *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *****************************************/</span>
</span></span><span style="display:flex;"><span>         caddr_t <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         fd <span style="color:#f92672">=</span> open (filename, O_RDWR <span style="color:#f92672">|</span> O_TRUNC <span style="color:#f92672">|</span> O_CREAT, <span style="color:#ae81ff">0644</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> fd)
</span></span><span style="display:flex;"><span>        errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;File write&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* NOT REACHED */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* If you don&#39;t do this, mmapping will never
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * work for writing to files
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * If you don&#39;t know file size in advance as is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * often the case with data streaming from the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * network, you can use a large value here. Once you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * write out the whole file, you can shrink it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to the correct size by calling ftruncate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> ftruncate(ctx<span style="color:#f92672">-&gt;</span>fd,filelen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mm <span style="color:#f92672">=</span> mmap(NULL, header<span style="color:#f92672">-&gt;</span>filelen, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE,
</span></span><span style="display:flex;"><span>                        MAP_SHARED, ctx<span style="color:#f92672">-&gt;</span>fd, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> mm)
</span></span><span style="display:flex;"><span>        errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;mmap() problem&#34;</span>);
</span></span><span style="display:flex;"><span>        memcpy(mm <span style="color:#f92672">+</span> off, buf, len);
</span></span><span style="display:flex;"><span>        off <span style="color:#f92672">+=</span> len;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Please don&#39;t forget to free mmap(2)ed memory!  */</span>
</span></span><span style="display:flex;"><span>        munmap(mm, filelen);
</span></span><span style="display:flex;"><span>        close(fd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/******************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * mmap(2) file read                      *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *                                        *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *****************************************/</span>
</span></span><span style="display:flex;"><span>        fd <span style="color:#f92672">=</span> open(filename, O_RDONLY, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> fd)
</span></span><span style="display:flex;"><span>        errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34; File read err&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* NOT REACHED */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fstat(fd, <span style="color:#f92672">&amp;</span>statbf);
</span></span><span style="display:flex;"><span>        filelen <span style="color:#f92672">=</span> statbf.st_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mm <span style="color:#f92672">=</span> mmap(NULL, filelen, PROT_READ, MAP_SHARED, fd, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> mm)
</span></span><span style="display:flex;"><span>        errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;mmap() error&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* NOT REACHED */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Now onward you can straightaway
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * do a memory copy of the mm pointer as it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * will dish out file data to you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        bufptr <span style="color:#f92672">=</span> mm <span style="color:#f92672">+</span> off;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* You can straightaway copy mmapped memory into the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           network buffer for sending */</span>
</span></span><span style="display:flex;"><span>        memcpy(pkt.buf <span style="color:#f92672">+</span> filenameoff, bufptr, bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Please don&#39;t forget to free mmap(2)ed memory!  */</span>
</span></span><span style="display:flex;"><span>        munmap(mm, filelen);
</span></span><span style="display:flex;"><span>        close(fd);
</span></span></code></pre></div><h2 id="socket-options-and-sendfile2">Socket Options and sendfile(2)</h2>
<p>TCP sockets under Linux come with a rich set of options with which you
can manipulate the functioning of the OS TCP/IP stack. A few options are
important for performance, such as the TCP send and receive buffer
sizes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>sndsize <span style="color:#f92672">=</span> <span style="color:#ae81ff">16384</span>;
</span></span><span style="display:flex;"><span>setsockopt(socket, SOL_SOCKET, SO_SNDBUF, (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>sndsize,
</span></span><span style="display:flex;"><span>		(<span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">sizeof</span>(sndsize)); 
</span></span><span style="display:flex;"><span>rcvsize <span style="color:#f92672">=</span> <span style="color:#ae81ff">16384</span>;
</span></span><span style="display:flex;"><span>setsockopt(socket, SOL_SOCKET, SO_RCVBUF, (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>rcvsize,
</span></span><span style="display:flex;"><span>		(<span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">sizeof</span>(rcvsize)); 
</span></span></code></pre></div><p>I am using conservative values here. Obviously, it should be much higher
for Gigabit networks. These values are determined by the bandwidth delay
product. Interestingly, I have never found this to be an issue, so I
doubt if this would give you a performance boost. It still is worth
mentioning, because the TCP window size alone can give you optimal
throughput.</p>
<p>Other options can be set using the /proc pseudo-filesystem under Linux
(including the above two), and unless your Linux distribution turns off
certain options, you won&rsquo;t have to tweak them.</p>
<p>It is also a good idea to enable PMTU (Path Maximum Transmission Unit)
discovery to avoid IP fragmentation. IP fragmentation can affect not
just performance, but surely it&rsquo;s more important regarding performance
than anything else. To avoid fragmentation at any cost, several HTTP
servers use conservative packet sizes. Doing so is not a very good
thing, as there is a corresponding increase in protocol overhead. More
packets mean more headers and wasted bandwidth.</p>
<p>Instead of using write(2) or send(2) for transfer, you could use the
sendfile(2) system call. This provides substantial savings in avoiding
redundant copies, as bits are passed between the file descriptor and
socket descriptor directly. Be aware that this approach is not portable
across UNIX.</p>
<p>Advanced Techniques in Application Design
Applications should be well designed to take full advantage of network
resources. First and foremost, using multiple short-lived TCP
connections between the same two endpoints for sequential processing is
wrong. It will work, but it will hurt performance and cause several
other headaches as well. Most notably, the TCP TIME_WAIT state has a
timeout of twice the maximum segment lifetime. Because the round-trip
time varies widely in busy networks and networks with high latency,
oftentimes this value will be inaccurate. There are other problems too,
but if you design your application well, with proper protocol headers
and PDU boundaries, there never should be a need to use different TCP
connections.</p>
<p>Take the case of SSH, for instance. How many different TCP streams are
multiplexed with just one connection? Take a cue from it.</p>
<p>You don&rsquo;t have to work in lockstep between the client and the server.
Simply because the protocols and algorithms are visualized in a fixed
sequence does not imply that the implementation should follow suit.</p>
<p>You can make excellent use of available bandwidth by doing things in
parallel—by not waiting for processing to complete before reading the
next packet off the network. Figure 2 illustrates what I mean.</p>
<p>High-Performance Networking Programming in C
Figure 2. Pipelining</p>
<p>Pipelining is a powerful technique employed in CPUs to speed up the
FETCH-DECODE-EXECUTE cycle. Here, we use the same technique for network
processing.</p>
<p>Obviously, your wire protocol should have the least overhead and should
work without relying much on future input. By keeping the state machine
fairly self-contained and isolated, you can process efficiently.</p>
<p>Avoiding redundant protocol headers or fields that are mostly empty or
unused can save you precious bandwidth for carrying real data payloads.
Header fields should be aligned at 32-bit boundaries and so should the C
structures that represent them.</p>
<p>If your application already is in production and you want to enhance its
performance, try some of the above techniques. It shouldn&rsquo;t be too much
trouble to attack the problem of re-engineering an application if you
take it one step at a time. And remember, never trust any theory—not
even this article. Test everything for yourself. If your testing does
not report improved performance, don&rsquo;t do it. Also, make sure your test
cases take care of LAN, WAN and, if necessary, satellite and wireless
environments.</p>
<p>A Few Words on TCP
TCP has been a field of intense research for decades. It&rsquo;s an extremely
complex protocol with a heavy responsibility on the Internet. We often
forget that TCP is what holds the Internet together without collapse due
to congestion. IP connects networks together, but TCP ensures that
routers are not overloaded and that packets do not get lost.</p>
<p>Consequently, the impact of TCP on performance is higher than any other
protocol today. It is no wonder that top-notch researchers have written
several papers on the topic.</p>
<p>The Internet is anything but homogeneous. There is every possible
physical layer of technology on which TCP/IP works today. But, TCP is
not designed for working well through wireless networks. Even a
high-latency satellite link questions some of TCP&rsquo;s assumptions on
window size and round-trip time measurement.</p>
<p>And, TCP is not without its share of defects. The congestion control
algorithms, such as slow start, congestion avoidance, fast retransmit,
fast recovery and so on, sometimes fail. When this happens, it hurts
your performance. Normally, three duplicate ACK packets are sufficient
for triggering congestion control mechanisms. No matter what you do,
these mechanisms can drastically decrease performance, especially if you
have a very high-speed network.</p>
<p>But, all else being equal, the above techniques are few of the most
useful methods for achieving good performance for your applications.</p>
<p>Conclusion
Gunning for very high performance is not something to be taken lightly.
It&rsquo;s dependent on heuristics and empirical data as well as proven
techniques. As I mentioned previously, it is an art best perfected by
practice, and it&rsquo;s also an iterative process. However, once you get a
feel for how things work, it will be smooth sailing. The moment you
build a stable base for a fast client/server interaction like this,
building powerful P2P frameworks on top is no great hassle.</p>
<h2 id="resources">Resources</h2>
<ul>
<li>
<p><a href="https://www.pps.jussieu.fr/~jch/software/polipo/manual">Polipo User Manual</a></p>
</li>
<li>
<p><a href="https://www.onlamp.com/pub/a/onlamp/2006/11/17/tcp_tuning.html">TCP Tuning and Network
Troubleshooting</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Bandwidth">Wikipedia&rsquo;s Definition of Bandwidth</a></p>
</li>
<li>
<p><a href="https://beej.us/guide/bgnet/output/html/multipage/advanced.html">Advanced Networking Techniques</a>j</p>
</li>
<li>
<p><a href="https://www.nishida.org/soi1/mgp00001.html">TCP and Congestion Control Slides</a></p>
</li>
</ul>

        </div>
      </div>
    </div>
  </div>
</article>

        </div><section class="footer">
  <div class="container">

    <div class="row justify-content-between">
        <div class="footer-logo">
          A digital nomad
        </div>
    </div>

<hr/>
    <div class="row justify-content-between">

<script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="girishV" data-color="#FFDD00" data-emoji=""  data-font="Arial" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" ></script>

<a href="https://twitter.com/girish1729?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @girish1729</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

   </div>

   <div class="footer-copyright-text">
          <p> © 2022 <a href="https://girish1729.github.io/" target="_blank">Girish Venkatachalam</a> </p>
    </div>

  </div>
</section>


<!-- Non Critical CSS -->

<link href="https://girish1729.github.io/scss/non-critical.min.css" rel="stylesheet" />
<script src="https://maps.googleapis.com/maps/api/js?key=&libraries=geometry">
</script>
<!-- VENDOR JS -->
<script src="https://girish1729.github.io/vendor/jQuery/jquery.min.js"></script>
<script src="https://girish1729.github.io/vendor/bootstrap/bootstrap.min.js"></script>
<script src="https://girish1729.github.io/vendor/slick/slick.min.js"></script>
<script src="https://girish1729.github.io/vendor/aos/aos.js"></script>
<script src="https://girish1729.github.io/vendor/match-height/match-height.js"></script>
<script src="https://girish1729.github.io/vendor/magnific-popup/magnific-popup.min.js"></script>
<script src="https://girish1729.github.io/vendor/g-map/gmap.js"></script>

 
<script src="https://girish1729.github.io/js/script.min.js"></script>


</body>
</html>
